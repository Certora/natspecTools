[
  {
    "type": "text",
    "text": "## Verification of ERC1155\n\n`ERC1155` establishes base level support\n[EIP1155](https://eips.ethereum.org/EIPS/eip-1155), a standard interface for\ncontracts that manage multiple token types. The contract was verified as part\nof previous work with OpenZeppelin and is included here for the purposes of\nincreased verification coverage with respect to token transfer methods.\n\n### Assumptions and Simplifications\n- Internal burn and mint methods are wrapped by CVT callable functions.\n\n### Properties\n\nThese properties are additions to the previous `ERC1155` verification.\nPlease see the file ERC1155.spec for earlier contract properties verified."
  },
  {
    "type": "rule",
    "id": "singleTokenSafeTransferFromSafeBatchTransferFromEquivalence",
    "title": "Single token safe transfer from safe batch transfer from equivalence",
    "content": "/// The result of transferring a single token must be equivalent whether done \n/// via safeTransferFrom or safeBatchTransferFrom.\nrule singleTokenSafeTransferFromSafeBatchTransferFromEquivalence {\n    storage beforeTransfer = lastStorage;\n    env e;\n\n    address holder; address recipient;\n    uint256 token; uint256 transferAmount; bytes data;\n    uint256[] tokens; uint256[] transferAmounts;\n\n    mathint holderStartingBalance = balanceOf(holder, token);\n    mathint recipientStartingBalance = balanceOf(recipient, token);\n\n    require tokens.length == 1; require transferAmounts.length == 1;\n    require tokens[0] == token; require transferAmounts[0] == transferAmount;\n\n    // transferring via safeTransferFrom\n    safeTransferFrom(e, holder, recipient, token, transferAmount, data) at beforeTransfer;\n    mathint holderSafeTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);\n    mathint recipientSafeTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;\n\n    // transferring via safeBatchTransferFrom\n    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfer;\n    mathint holderSafeBatchTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);\n    mathint recipientSafeBatchTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;\n\n    assert holderSafeTransferFromBalanceChange == holderSafeBatchTransferFromBalanceChange\n        && recipientSafeTransferFromBalanceChange == recipientSafeBatchTransferFromBalanceChange, \n        \"Transferring a single token via safeTransferFrom or safeBatchTransferFrom must be equivalent\";\n}   ",
    "notice": "The result of transferring a single token must be equivalent whether done \nvia safeTransferFrom or safeBatchTransferFrom."
  },
  {
    "type": "rule",
    "id": "multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence",
    "title": "Multiple token safe transfer from safe batch transfer from equivalence",
    "content": "/// The results of transferring multiple tokens must be equivalent whether done \n/// separately via safeTransferFrom or together via safeBatchTransferFrom.\nrule multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence {\n    storage beforeTransfers = lastStorage;\n    env e;\n\n    address holder; address recipient; bytes data;\n    uint256 tokenA; uint256 tokenB; uint256 tokenC;\n    uint256 transferAmountA; uint256 transferAmountB; uint256 transferAmountC;\n    uint256[] tokens; uint256[] transferAmounts;\n\n    mathint holderStartingBalanceA = balanceOf(holder, tokenA);\n    mathint holderStartingBalanceB = balanceOf(holder, tokenB);\n    mathint holderStartingBalanceC = balanceOf(holder, tokenC);\n    mathint recipientStartingBalanceA = balanceOf(recipient, tokenA);\n    mathint recipientStartingBalanceB = balanceOf(recipient, tokenB);\n    mathint recipientStartingBalanceC = balanceOf(recipient, tokenC);\n\n    require tokens.length == 3; require transferAmounts.length == 3;\n    require tokens[0] == tokenA; require transferAmounts[0] == transferAmountA;\n    require tokens[1] == tokenB; require transferAmounts[1] == transferAmountB;\n    require tokens[2] == tokenC; require transferAmounts[2] == transferAmountC;\n\n    // transferring via safeTransferFrom\n    safeTransferFrom(e, holder, recipient, tokenA, transferAmountA, data) at beforeTransfers;\n    safeTransferFrom(e, holder, recipient, tokenB, transferAmountB, data);\n    safeTransferFrom(e, holder, recipient, tokenC, transferAmountC, data);\n    mathint holderSafeTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);\n    mathint holderSafeTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);\n    mathint holderSafeTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);\n    mathint recipientSafeTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;\n    mathint recipientSafeTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;\n    mathint recipientSafeTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;\n\n    // transferring via safeBatchTransferFrom\n    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfers;\n    mathint holderSafeBatchTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);\n    mathint holderSafeBatchTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);\n    mathint holderSafeBatchTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);\n    mathint recipientSafeBatchTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;\n    mathint recipientSafeBatchTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;\n    mathint recipientSafeBatchTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;\n\n    assert holderSafeTransferFromBalanceChangeA == holderSafeBatchTransferFromBalanceChangeA\n        && holderSafeTransferFromBalanceChangeB == holderSafeBatchTransferFromBalanceChangeB\n        && holderSafeTransferFromBalanceChangeC == holderSafeBatchTransferFromBalanceChangeC\n        && recipientSafeTransferFromBalanceChangeA == recipientSafeBatchTransferFromBalanceChangeA\n        && recipientSafeTransferFromBalanceChangeB == recipientSafeBatchTransferFromBalanceChangeB\n        && recipientSafeTransferFromBalanceChangeC == recipientSafeBatchTransferFromBalanceChangeC, \n        \"Transferring multiple tokens via safeTransferFrom or safeBatchTransferFrom must be equivalent\";\n}",
    "notice": "The results of transferring multiple tokens must be equivalent whether done \nseparately via safeTransferFrom or together via safeBatchTransferFrom."
  },
  {
    "type": "rule",
    "id": "transfersHaveSameLengthInputArrays",
    "title": "Transfers have same length input arrays",
    "content": "/// If transfer methods do not revert, the input arrays must be the same length.\nrule transfersHaveSameLengthInputArrays {\n    env e;\n\n    address recipient; bytes data;\n    uint256[] tokens; uint256[] transferAmounts;\n    uint max_int = 0xffffffffffffffffffffffffffffffff;\n\n    require tokens.length >= 0 && tokens.length <= max_int;\n    require transferAmounts.length >= 0 && transferAmounts.length <= max_int;\n\n    safeBatchTransferFrom(e, _, recipient, tokens, transferAmounts, data);\n\n    uint256 tokensLength = tokens.length;\n    uint256 transferAmountsLength = transferAmounts.length;\n\n    assert tokens.length == transferAmounts.length, \n        \"If transfer methods do not revert, the input arrays must be the same length\";\n}",
    "notice": "If transfer methods do not revert, the input arrays must be the same length."
  }
]
